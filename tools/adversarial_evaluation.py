#!/usr/bin/env python3
"""
Adversarial Evaluation System for Claude CODE
Evaluates product proposals generated by Claude.ai Research feature
"""

import json
import sys
import os
from datetime import datetime
from typing import List, Dict, Any
import re


class ProposalParser:
    """Parses product proposals from markdown files"""
    
    def __init__(self, file_path: str):
        self.file_path = file_path
        
    def parse(self) -> List[Dict[str, Any]]:
        """Extract structured ideas from proposal document"""
        
        if not os.path.exists(self.file_path):
            raise FileNotFoundError(f"Proposal file not found: {self.file_path}")
            
        with open(self.file_path, 'r') as f:
            content = f.read()
            
        ideas = []
        
        # Parse markdown sections for each idea
        # Expecting format like:
        # ## 1. Product Name
        # **Tagline**: ...
        # **Market Type**: B2B/B2C
        # **Target Customer**: ...
        # **Problem**: ...
        # **Solution**: ...
        # **Pricing**: ...
        # **Why Now**: ...
        # **Moat**: ...
        
        # Split by idea headers (## 1., ## 2., etc.)
        idea_sections = re.split(r'^##\s+\d+\.\s+', content, flags=re.MULTILINE)[1:]
        
        for section in idea_sections:
            lines = section.strip().split('\n')
            if not lines:
                continue
                
            idea = {
                'name': lines[0].strip(),
                'tagline': '',
                'market_type': '',
                'target_customer': '',
                'problem': '',
                'solution': '',
                'pricing': '',
                'why_now': '',
                'moat': ''
            }
            
            # Parse each field
            current_field = None
            current_value = []
            
            for line in lines[1:]:
                if line.startswith('**') and '**:' in line:
                    # Save previous field
                    if current_field:
                        idea[current_field] = ' '.join(current_value).strip()
                    
                    # Start new field
                    field_match = re.match(r'\*\*(.+?)\*\*:\s*(.*)$', line)
                    if field_match:
                        field_name = field_match.group(1).lower().replace(' ', '_')
                        field_value = field_match.group(2)
                        
                        # Map common variations
                        field_map = {
                            'market': 'market_type',
                            'type': 'market_type',
                            'target': 'target_customer',
                            'customer': 'target_customer',
                            'price': 'pricing',
                            'defensibility': 'moat'
                        }
                        
                        current_field = field_map.get(field_name, field_name)
                        current_value = [field_value] if field_value else []
                elif line.strip() and current_field:
                    current_value.append(line.strip())
            
            # Save last field
            if current_field:
                idea[current_field] = ' '.join(current_value).strip()
            
            if idea['name']:  # Only add if we got a valid name
                ideas.append(idea)
                
        print(f"‚úÖ Parsed {len(ideas)} ideas from proposal")
        return ideas


class SkepticalInvestor:
    """Challenges unit economics and scalability"""
    
    def __init__(self):
        self.role = "Skeptical Investor"
        self.criteria = ["unit_economics", "scalability", "market_size", "profitability"]
    
    def evaluate(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate idea from investor perspective"""
        
        print(f"üí∞ {self.role}: Evaluating {idea.get('name', 'idea')}...")
        
        # Scoring logic based on idea attributes
        score = 5  # Start neutral
        fatal_flaws = []
        concerns = []
        
        # Check market type
        market_type = idea.get('market_type', '').upper()
        if 'B2B' in market_type:
            score += 1  # B2B typically has better unit economics
        
        # Check pricing
        pricing = idea.get('pricing', '').lower()
        if any(x in pricing for x in ['$100', '$150', '$200']):
            score += 2  # Higher price points are better
        elif any(x in pricing for x in ['$5', '$7']):
            score -= 2
            concerns.append("Price point too low for sustainable unit economics")
        elif '$9.99' in pricing and 'B2C' in market_type:
            score -= 1  # Acceptable for B2C but not ideal
            
        # Check for clear target market
        if len(idea.get('target_customer', '')) < 20:
            fatal_flaws.append("Target customer not specific enough for GTM")
            
        # Check moat
        if len(idea.get('moat', '')) < 30:
            concerns.append("Weak competitive moat")
            score -= 1
            
        verdict = "KILL" if fatal_flaws or score < 4 else "PROCEED"
        
        return {
            "score": max(1, min(10, score)),
            "fatal_flaws": fatal_flaws,
            "concerns": concerns,
            "verdict": verdict
        }


class BurnedEntrepreneur:
    """Spots operational complexity and scaling nightmares"""
    
    def __init__(self):
        self.role = "Burned Entrepreneur"
        self.criteria = ["operational_complexity", "support_burden", "edge_cases", "dependencies"]
    
    def evaluate(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate from bitter experience"""
        
        print(f"üò§ {self.role}: Evaluating {idea.get('name', 'idea')}...")
        
        score = 5
        fatal_flaws = []
        concerns = []
        
        # Check for red flag words indicating complexity
        solution = idea.get('solution', '').lower()
        problem = idea.get('problem', '').lower()
        
        complexity_flags = ['integrate', 'platform', 'marketplace', 'social', 'community', 
                           'real-time', 'ai-powered', 'machine learning', 'blockchain']
        
        complexity_count = sum(1 for flag in complexity_flags if flag in solution or flag in problem)
        score -= complexity_count
        
        if complexity_count > 2:
            fatal_flaws.append("Too many complex moving parts for 15hr/week operation")
            
        # B2C concerns
        if 'B2C' in idea.get('market_type', ''):
            concerns.append("B2C support will explode beyond 15hrs/week")
            score -= 1
            
        # Check for external dependencies
        if any(x in solution for x in ['api', 'third-party', 'integration']):
            concerns.append("External dependency risk")
            score -= 1
            
        verdict = "KILL" if fatal_flaws or score < 3 else "PROCEED"
        
        return {
            "score": max(1, min(10, score)),
            "fatal_flaws": fatal_flaws,
            "concerns": concerns,
            "verdict": verdict
        }


class TargetCustomer:
    """Validates real need and willingness to pay"""
    
    def __init__(self):
        self.role = "Target Customer"
        self.criteria = ["real_need", "willingness_to_pay", "switching_cost", "current_solution"]
    
    def evaluate(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate from customer perspective"""
        
        print(f"üéØ {self.role}: Evaluating {idea.get('name', 'idea')}...")
        
        score = 5
        fatal_flaws = []
        concerns = []
        
        # Check if problem is specific and painful
        problem = idea.get('problem', '')
        if len(problem) < 50:
            fatal_flaws.append("Problem not clearly articulated")
            
        # Check if solution is clear
        solution = idea.get('solution', '')
        if 'somehow' in solution.lower() or 'maybe' in solution.lower():
            concerns.append("Solution too vague")
            score -= 2
            
        # Price sensitivity
        pricing = idea.get('pricing', '').lower()
        market_type = idea.get('market_type', '')
        
        if 'B2C' in market_type and any(x in pricing for x in ['$50', '$100', '$150']):
            concerns.append("B2C customers unlikely to pay this much monthly")
            score -= 2
            
        # Check for existing behavior change required
        if any(x in solution.lower() for x in ['new way', 'change how', 'revolutionize']):
            concerns.append("Requires significant behavior change")
            score -= 1
            
        verdict = "KILL" if fatal_flaws or score < 4 else "PROCEED"
        
        return {
            "score": max(1, min(10, score)),
            "fatal_flaws": fatal_flaws,
            "concerns": concerns,
            "verdict": verdict
        }


class TechnicalRealist:
    """Assesses buildability with Claude CODE"""
    
    def __init__(self):
        self.role = "Technical Realist"
        self.criteria = ["technical_feasibility", "maintenance_burden", "security", "scalability"]
    
    def evaluate(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate technical feasibility"""
        
        print(f"‚öôÔ∏è {self.role}: Evaluating {idea.get('name', 'idea')}...")
        
        score = 6  # Start optimistic about Claude CODE capabilities
        fatal_flaws = []
        concerns = []
        
        solution = idea.get('solution', '').lower()
        
        # Check for technically complex features
        hard_features = ['video processing', 'voice recognition', 'real-time collaboration', 'mobile app', 
                        'native app', 'hardware', 'iot', 'blockchain', ' vr ', ' ar ', 'augmented reality']
        
        for feature in hard_features:
            if feature in solution.lower():
                fatal_flaws.append(f"Cannot build {feature} features with current stack")
                
        # Check for data/ML requirements
        if any(x in solution for x in ['predict', 'recommend', 'personalize', 'analyze patterns']):
            concerns.append("ML/data requirements add complexity")
            score -= 2
            
        # Security concerns for B2B
        if 'B2B' in idea.get('market_type', '') and any(x in solution for x in ['data', 'financial', 'sensitive']):
            concerns.append("Enterprise security requirements")
            score -= 1
            
        # Simple CRUD apps get bonus
        if all(x not in solution for x in hard_features) and len(solution) < 200:
            score += 2  # Likely a simple web app
            
        verdict = "KILL" if fatal_flaws or score < 4 else "PROCEED"
        
        return {
            "score": max(1, min(10, score)),
            "fatal_flaws": fatal_flaws,
            "concerns": concerns,
            "verdict": verdict
        }


class MarketAnalyst:
    """Checks competition and market timing"""
    
    def __init__(self):
        self.role = "Market Analyst"
        self.criteria = ["competition", "differentiation", "market_timing", "previous_failures"]
    
    def evaluate(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate market position"""
        
        print(f"üìä {self.role}: Evaluating {idea.get('name', 'idea')}...")
        
        score = 5
        fatal_flaws = []
        concerns = []
        
        # Check why now
        why_now = idea.get('why_now', '')
        if len(why_now) < 30:
            concerns.append("No clear reason why this timing is right")
            score -= 2
            
        # Generic ideas get penalized
        name = idea.get('name', '').lower()
        tagline = idea.get('tagline', '').lower()
        
        generic_terms = ['tool', 'platform', 'solution', 'app', 'system', 'manager']
        if sum(1 for term in generic_terms if term in name or term in tagline) > 1:
            concerns.append("Too generic, likely crowded market")
            score -= 2
            
        # Niche markets get bonus
        target = idea.get('target_customer', '').lower()
        if any(x in target for x in ['specific', 'niche', 'specialized', 'particular']):
            score += 1
            
        # Check for venture-backed competition indicators
        solution_lower = idea.get('solution', '').lower()
        if any(x in solution_lower for x in ['crm', 'project management tool', 'general scheduling', 'accounting software']):
            fatal_flaws.append("Category dominated by funded competitors")
            
        verdict = "KILL" if fatal_flaws or score < 4 else "PROCEED"
        
        return {
            "score": max(1, min(10, score)),
            "fatal_flaws": fatal_flaws,
            "concerns": concerns,
            "verdict": verdict
        }


class AdversarialEvaluator:
    """Runs adversarial evaluation on provided proposals"""
    
    def __init__(self, proposal_file: str):
        self.proposal_file = proposal_file
        self.parser = ProposalParser(proposal_file)
        self.adversaries = [
            SkepticalInvestor(),
            BurnedEntrepreneur(),
            TargetCustomer(),
            TechnicalRealist(),
            MarketAnalyst()
        ]
        self.results = []
    
    def run_evaluation(self) -> Dict[str, Any]:
        """Execute adversarial evaluation on proposal"""
        
        print(f"üöÄ Starting Adversarial Evaluation")
        print(f"üìÑ Reading proposal from: {self.proposal_file}")
        print("=" * 50)
        
        # Parse ideas from proposal
        try:
            ideas = self.parser.parse()
        except Exception as e:
            print(f"‚ùå Error parsing proposal: {e}")
            return {"error": str(e)}
            
        if not ideas:
            print("‚ùå No ideas found in proposal")
            return {"error": "No ideas found in proposal"}
            
        print(f"\n‚úÖ Found {len(ideas)} ideas to evaluate")
        
        # Phase 2: Adversarial Review
        print("\nüî• Beginning Adversarial Review")
        print("-" * 50)
        
        for i, idea in enumerate(ideas, 1):
            print(f"\n[{i}/{len(ideas)}] Evaluating: {idea.get('name', 'Unnamed')}")
            result = self._evaluate_idea(idea)
            self.results.append(result)
            
            if result['verdict'] == 'KILL':
                print(f"‚ùå KILLED by {result['killed_by']}: {result['kill_reason']}")
            else:
                print(f"‚úÖ SURVIVED (Score: {result['total_score']}/50)")
        
        # Generate report
        report = self._generate_report()
        
        # Save results
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        report_path = f"phases/phase-1/evaluation-{timestamp}.md"
        data_path = f"phases/phase-1/evaluation-{timestamp}.json"
        
        self._save_results(report, report_path, data_path)
        
        return {
            "ideas_evaluated": len(ideas),
            "ideas_survived": len([r for r in self.results if r['verdict'] == 'PROCEED']),
            "ideas_killed": len([r for r in self.results if r['verdict'] == 'KILL']),
            "report_path": report_path,
            "data_path": data_path
        }
    
    def _evaluate_idea(self, idea: Dict[str, Any]) -> Dict[str, Any]:
        """Run idea through all adversarial personas"""
        
        result = {
            "idea": idea,
            "evaluations": {},
            "total_score": 0,
            "verdict": "PROCEED",
            "killed_by": None,
            "kill_reason": None
        }
        
        for adversary in self.adversaries:
            evaluation = adversary.evaluate(idea)
            persona_name = adversary.__class__.__name__
            result['evaluations'][persona_name] = evaluation
            result['total_score'] += evaluation['score']
            
            # Check for fatal flaws
            if evaluation['verdict'] == 'KILL' and evaluation['fatal_flaws']:
                result['verdict'] = 'KILL'
                result['killed_by'] = persona_name
                result['kill_reason'] = evaluation['fatal_flaws'][0]
                break
        
        # Check minimum score threshold (25/50 = 50%)
        if result['verdict'] == 'PROCEED' and result['total_score'] < 25:
            result['verdict'] = 'KILL'
            result['killed_by'] = 'Low Score'
            result['kill_reason'] = f"Total score {result['total_score']}/50 below threshold"
        
        return result
    
    def _generate_report(self) -> str:
        """Create markdown report of results"""
        
        survivors = [r for r in self.results if r['verdict'] == 'PROCEED']
        killed = [r for r in self.results if r['verdict'] == 'KILL']
        
        report = f"""# Adversarial Evaluation Results
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}
Proposal: {self.proposal_file}

## Summary
- **Ideas Evaluated**: {len(self.results)}
- **Ideas Survived**: {len(survivors)} ‚úÖ
- **Ideas Killed**: {len(killed)} ‚ùå
- **Survival Rate**: {len(survivors)/len(self.results)*100:.1f}%

## Surviving Ideas

"""
        
        # Sort survivors by score
        survivors.sort(key=lambda x: x['total_score'], reverse=True)
        
        for i, result in enumerate(survivors, 1):
            idea = result['idea']
            report += f"""### {i}. {idea.get('name', 'Unnamed')}
**Type**: {idea.get('market_type', 'Unknown')}  
**Tagline**: {idea.get('tagline', 'No tagline')}  
**Target**: {idea.get('target_customer', 'Unknown')}  
**Price**: {idea.get('pricing', 'TBD')}  
**Score**: {result['total_score']}/50

**Problem**: {idea.get('problem', 'Not specified')}

**Solution**: {idea.get('solution', 'Not specified')}

**Scores by Persona**:
"""
            
            for persona, evaluation in result['evaluations'].items():
                emoji = "‚úÖ" if evaluation['score'] >= 7 else "‚ö†Ô∏è" if evaluation['score'] >= 5 else "‚ùå"
                report += f"- {persona}: {evaluation['score']}/10 {emoji}\n"
                
            # Add concerns
            all_concerns = []
            for evaluation in result['evaluations'].values():
                all_concerns.extend(evaluation['concerns'])
                
            if all_concerns:
                report += f"\n**Key Concerns**:\n"
                for concern in all_concerns[:3]:  # Top 3 concerns
                    report += f"- {concern}\n"
            
            report += "\n---\n\n"
        
        # Killed ideas section
        report += "\n## Killed Ideas\n\n"
        
        kill_by_persona = {}
        for result in killed:
            idea = result['idea']
            killer = result['killed_by']
            kill_by_persona[killer] = kill_by_persona.get(killer, 0) + 1
            
            report += f"**{idea.get('name', 'Unnamed')}** ({idea.get('market_type', 'Unknown')})\n"
            report += f"- Killed by: {killer}\n"
            report += f"- Reason: {result['kill_reason']}\n"
            report += f"- Score at death: {result['total_score']}/50\n\n"
        
        # Add patterns
        report += self._analyze_patterns(kill_by_persona)
        
        return report
    
    def _analyze_patterns(self, kill_by_persona: Dict[str, int]) -> str:
        """Identify patterns in failures and successes"""
        
        patterns = "\n## Patterns & Insights\n\n"
        
        # Kill patterns
        if kill_by_persona:
            patterns += "### Top Idea Killers\n"
            for killer, count in sorted(kill_by_persona.items(), key=lambda x: x[1], reverse=True):
                percentage = count / len([r for r in self.results if r['verdict'] == 'KILL']) * 100
                patterns += f"- {killer}: {count} ideas ({percentage:.0f}% of kills)\n"
        
        # Market type analysis
        b2b_total = len([r for r in self.results if 'B2B' in r['idea'].get('market_type', '')])
        b2c_total = len([r for r in self.results if 'B2C' in r['idea'].get('market_type', '')])
        b2b_survived = len([r for r in self.results if r['verdict'] == 'PROCEED' and 'B2B' in r['idea'].get('market_type', '')])
        b2c_survived = len([r for r in self.results if r['verdict'] == 'PROCEED' and 'B2C' in r['idea'].get('market_type', '')])
        
        if b2b_total > 0 or b2c_total > 0:
            patterns += f"\n### Market Type Performance\n"
            if b2b_total > 0:
                patterns += f"- B2B: {b2b_survived}/{b2b_total} survived ({b2b_survived/b2b_total*100:.0f}%)\n"
            if b2c_total > 0:
                patterns += f"- B2C: {b2c_survived}/{b2c_total} survived ({b2c_survived/b2c_total*100:.0f}%)\n"
        
        # Success patterns
        if len([r for r in self.results if r['verdict'] == 'PROCEED']) > 0:
            patterns += "\n### Success Patterns\n"
            patterns += "Ideas that survived typically had:\n"
            
            # Analyze common traits
            high_scorers = [r for r in self.results if r['verdict'] == 'PROCEED' and r['total_score'] >= 35]
            if high_scorers:
                patterns += f"- High scores (35+/50): {len(high_scorers)} ideas\n"
                
            patterns += "- Clear, specific target audience\n"
            patterns += "- Simple technical implementation\n"
            patterns += "- Realistic pricing for market type\n"
            patterns += "- Strong 'why now' reasoning\n"
        
        return patterns
    
    def _save_results(self, report: str, report_path: str, data_path: str):
        """Save results to files"""
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        
        # Save markdown report
        with open(report_path, 'w') as f:
            f.write(report)
        
        # Save JSON data for further analysis
        with open(data_path, 'w') as f:
            json.dump({
                "session_date": datetime.now().isoformat(),
                "proposal_file": self.proposal_file,
                "results": self.results
            }, f, indent=2)
        
        print(f"\nüìÑ Report saved to: {report_path}")
        print(f"üìä Data saved to: {data_path}")


def main():
    """Run adversarial evaluation on proposal file"""
    
    if len(sys.argv) < 2:
        print("‚ùå Error: Please provide a proposal file path")
        print("Usage: python adversarial_evaluation.py <proposal-file.md>")
        sys.exit(1)
        
    proposal_file = sys.argv[1]
    
    evaluator = AdversarialEvaluator(proposal_file)
    results = evaluator.run_evaluation()
    
    if "error" not in results:
        print("\n" + "=" * 50)
        print("‚úÖ Adversarial Evaluation Complete!")
        print(f"üéØ {results['ideas_survived']} ideas ready for validation research")
        print(f"üìÑ Full report: {results['report_path']}")
    else:
        print(f"\n‚ùå Evaluation failed: {results['error']}")
        sys.exit(1)


if __name__ == "__main__":
    main()